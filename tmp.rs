cargo:rerun-if-changed=wrapper.h
/* automatically generated by rust-bindgen 0.69.1 */

#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
pub const NILSXP: u32 = 0;
pub const SYMSXP: u32 = 1;
pub const LISTSXP: u32 = 2;
pub const CLOSXP: u32 = 3;
pub const ENVSXP: u32 = 4;
pub const PROMSXP: u32 = 5;
pub const LANGSXP: u32 = 6;
pub const SPECIALSXP: u32 = 7;
pub const BUILTINSXP: u32 = 8;
pub const CHARSXP: u32 = 9;
pub const LGLSXP: u32 = 10;
pub const INTSXP: u32 = 13;
pub const REALSXP: u32 = 14;
pub const CPLXSXP: u32 = 15;
pub const STRSXP: u32 = 16;
pub const DOTSXP: u32 = 17;
pub const ANYSXP: u32 = 18;
pub const VECSXP: u32 = 19;
pub const EXPRSXP: u32 = 20;
pub const BCODESXP: u32 = 21;
pub const EXTPTRSXP: u32 = 22;
pub const WEAKREFSXP: u32 = 23;
pub const RAWSXP: u32 = 24;
pub const OBJSXP: u32 = 25;
extern "C" {
    pub static mut R_NaReal: f64;
}
extern "C" {
    pub static mut R_NaInt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn R_IsNA(arg1: f64) -> ::std::os::raw::c_int;
}
pub const Rboolean_FALSE: Rboolean = 0;
pub const Rboolean_TRUE: Rboolean = 1;
pub type Rboolean = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union Rcomplex {
    pub __bindgen_anon_1: Rcomplex__bindgen_ty_1,
    pub private_data_c: __BindgenComplex<f64>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rcomplex__bindgen_ty_1 {
    pub r: f64,
    pub i: f64,
}
#[test]
fn bindgen_test_layout_Rcomplex__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<Rcomplex__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Rcomplex__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(Rcomplex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Rcomplex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Rcomplex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rcomplex__bindgen_ty_1),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Rcomplex__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
}
#[test]
fn bindgen_test_layout_Rcomplex() {
    const UNINIT: ::std::mem::MaybeUninit<Rcomplex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Rcomplex>(),
        16usize,
        concat!("Size of: ", stringify!(Rcomplex))
    );
    assert_eq!(
        ::std::mem::align_of::<Rcomplex>(),
        8usize,
        concat!("Alignment of ", stringify!(Rcomplex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data_c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rcomplex),
            "::",
            stringify!(private_data_c)
        )
    );
}
extern "C" {
    pub fn Rprintf(arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn REprintf(arg1: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DllInfo {
    _unused: [u8; 0],
}
pub type DllInfo = _DllInfo;
pub type R_xlen_t = isize;
pub type SEXPTYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SEXPREC {
    _unused: [u8; 0],
}
pub type SEXP = *mut SEXPREC;
extern "C" {
    pub fn R_CHAR(x: SEXP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Rf_isLogical(s: SEXP) -> Rboolean;
}
extern "C" {
    pub fn Rf_isReal(s: SEXP) -> Rboolean;
}
extern "C" {
    pub fn Rf_isComplex(s: SEXP) -> Rboolean;
}
extern "C" {
    pub fn Rf_isEnvironment(s: SEXP) -> Rboolean;
}
extern "C" {
    pub fn Rf_isString(s: SEXP) -> Rboolean;
}
extern "C" {
    pub fn TYPEOF(x: SEXP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MARK_NOT_MUTABLE(x: SEXP);
}
extern "C" {
    pub fn LOGICAL(x: SEXP) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn INTEGER(x: SEXP) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn REAL(x: SEXP) -> *mut f64;
}
extern "C" {
    pub fn COMPLEX(x: SEXP) -> *mut Rcomplex;
}
extern "C" {
    pub fn LOGICAL_RO(x: SEXP) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn INTEGER_RO(x: SEXP) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn REAL_RO(x: SEXP) -> *const f64;
}
extern "C" {
    pub fn COMPLEX_RO(x: SEXP) -> *const Rcomplex;
}
extern "C" {
    pub fn VECTOR_ELT(x: SEXP, i: R_xlen_t) -> SEXP;
}
extern "C" {
    pub fn SET_STRING_ELT(x: SEXP, i: R_xlen_t, v: SEXP);
}
extern "C" {
    pub fn SET_VECTOR_ELT(x: SEXP, i: R_xlen_t, v: SEXP) -> SEXP;
}
extern "C" {
    pub fn STRING_PTR(x: SEXP) -> *mut SEXP;
}
extern "C" {
    pub fn STRING_PTR_RO(x: SEXP) -> *const SEXP;
}
extern "C" {
    pub fn CDR(e: SEXP) -> SEXP;
}
extern "C" {
    pub fn SET_TAG(x: SEXP, y: SEXP);
}
extern "C" {
    pub fn SETCAR(x: SEXP, y: SEXP) -> SEXP;
}
extern "C" {
    pub fn SETCDR(x: SEXP, y: SEXP) -> SEXP;
}
extern "C" {
    pub static mut R_GlobalEnv: SEXP;
}
extern "C" {
    pub static mut R_NilValue: SEXP;
}
extern "C" {
    pub static mut R_ClassSymbol: SEXP;
}
extern "C" {
    pub static mut R_DimSymbol: SEXP;
}
extern "C" {
    pub static mut R_NamesSymbol: SEXP;
}
extern "C" {
    pub static mut R_NaString: SEXP;
}
extern "C" {
    pub fn Rf_coerceVector(arg1: SEXP, arg2: SEXPTYPE) -> SEXP;
}
extern "C" {
    pub fn Rf_cons(arg1: SEXP, arg2: SEXP) -> SEXP;
}
extern "C" {
    pub fn Rf_duplicate(arg1: SEXP) -> SEXP;
}
extern "C" {
    pub fn Rf_eval(arg1: SEXP, arg2: SEXP) -> SEXP;
}
extern "C" {
    pub fn Rf_getAttrib(arg1: SEXP, arg2: SEXP) -> SEXP;
}
extern "C" {
    pub fn Rf_install(arg1: *const ::std::os::raw::c_char) -> SEXP;
}
extern "C" {
    pub fn Rf_setAttrib(arg1: SEXP, arg2: SEXP, arg3: SEXP) -> SEXP;
}
extern "C" {
    pub fn Rf_type2char(arg1: SEXPTYPE) -> *const ::std::os::raw::c_char;
}
pub const cetype_t_CE_NATIVE: cetype_t = 0;
pub const cetype_t_CE_UTF8: cetype_t = 1;
pub const cetype_t_CE_LATIN1: cetype_t = 2;
pub const cetype_t_CE_BYTES: cetype_t = 3;
pub const cetype_t_CE_SYMBOL: cetype_t = 5;
pub const cetype_t_CE_ANY: cetype_t = 99;
pub type cetype_t = ::std::os::raw::c_int;
extern "C" {
    pub fn Rf_mkCharLenCE(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: cetype_t,
    ) -> SEXP;
}
extern "C" {
    pub fn R_MakeExternalPtr(p: *mut ::std::os::raw::c_void, tag: SEXP, prot: SEXP) -> SEXP;
}
extern "C" {
    pub fn R_ExternalPtrAddr(s: SEXP) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn R_ClearExternalPtr(s: SEXP);
}
pub type R_CFinalizer_t = ::std::option::Option<unsafe extern "C" fn(arg1: SEXP)>;
extern "C" {
    pub fn R_RegisterCFinalizerEx(s: SEXP, fun: R_CFinalizer_t, onexit: Rboolean);
}
extern "C" {
    pub fn Rf_errorcall(arg1: SEXP, arg2: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    pub fn R_PreserveObject(arg1: SEXP);
}
extern "C" {
    pub fn R_compute_identical(arg1: SEXP, arg2: SEXP, arg3: ::std::os::raw::c_int) -> Rboolean;
}
extern "C" {
    pub fn Rf_allocVector(arg1: SEXPTYPE, arg2: R_xlen_t) -> SEXP;
}
extern "C" {
    pub fn Rf_isFunction(arg1: SEXP) -> Rboolean;
}
extern "C" {
    pub fn Rf_isInteger(arg1: SEXP) -> Rboolean;
}
extern "C" {
    pub fn Rf_lcons(arg1: SEXP, arg2: SEXP) -> SEXP;
}
extern "C" {
    pub fn Rf_ScalarComplex(arg1: Rcomplex) -> SEXP;
}
extern "C" {
    pub fn Rf_ScalarInteger(arg1: ::std::os::raw::c_int) -> SEXP;
}
extern "C" {
    pub fn Rf_ScalarLogical(arg1: ::std::os::raw::c_int) -> SEXP;
}
extern "C" {
    pub fn Rf_ScalarReal(arg1: f64) -> SEXP;
}
extern "C" {
    pub fn Rf_ScalarString(arg1: SEXP) -> SEXP;
}
extern "C" {
    pub fn Rf_xlength(arg1: SEXP) -> R_xlen_t;
}
extern "C" {
    pub fn Rf_protect(arg1: SEXP) -> SEXP;
}
extern "C" {
    pub fn Rf_unprotect(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CAR(e: SEXP) -> SEXP;
}
extern "C" {
    pub fn INTEGER_ELT(x: SEXP, i: R_xlen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn REAL_ELT(x: SEXP, i: R_xlen_t) -> f64;
}
extern "C" {
    pub fn LOGICAL_ELT(x: SEXP, i: R_xlen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn COMPLEX_ELT(x: SEXP, i: R_xlen_t) -> Rcomplex;
}
extern "C" {
    pub fn STRING_ELT(x: SEXP, i: R_xlen_t) -> SEXP;
}
extern "C" {
    pub fn SET_LOGICAL_ELT(x: SEXP, i: R_xlen_t, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SET_INTEGER_ELT(x: SEXP, i: R_xlen_t, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SET_COMPLEX_ELT(x: SEXP, i: R_xlen_t, v: Rcomplex);
}
extern "C" {
    pub fn ALTREP_CLASS(x: SEXP) -> SEXP;
}
extern "C" {
    pub fn R_altrep_data1(x: SEXP) -> SEXP;
}
extern "C" {
    pub fn R_altrep_data2(x: SEXP) -> SEXP;
}
extern "C" {
    pub fn R_set_altrep_data1(x: SEXP, v: SEXP);
}
extern "C" {
    pub fn R_set_altrep_data2(x: SEXP, v: SEXP);
}
extern "C" {
    pub fn ALTREP(x: SEXP) -> ::std::os::raw::c_int;
}
pub const ParseStatus_PARSE_NULL: ParseStatus = 0;
pub const ParseStatus_PARSE_OK: ParseStatus = 1;
pub const ParseStatus_PARSE_INCOMPLETE: ParseStatus = 2;
pub const ParseStatus_PARSE_ERROR: ParseStatus = 3;
pub const ParseStatus_PARSE_EOF: ParseStatus = 4;
pub type ParseStatus = ::std::os::raw::c_int;
extern "C" {
    pub fn R_ParseVector(
        arg1: SEXP,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ParseStatus,
        arg4: SEXP,
    ) -> SEXP;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct R_altrep_class_t {
    pub ptr: SEXP,
}
#[test]
fn bindgen_test_layout_R_altrep_class_t() {
    const UNINIT: ::std::mem::MaybeUninit<R_altrep_class_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<R_altrep_class_t>(),
        8usize,
        concat!("Size of: ", stringify!(R_altrep_class_t))
    );
    assert_eq!(
        ::std::mem::align_of::<R_altrep_class_t>(),
        8usize,
        concat!("Alignment of ", stringify!(R_altrep_class_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(R_altrep_class_t),
            "::",
            stringify!(ptr)
        )
    );
}
extern "C" {
    pub fn R_new_altrep(aclass: R_altrep_class_t, data1: SEXP, data2: SEXP) -> SEXP;
}
extern "C" {
    pub fn R_make_altstring_class(
        cname: *const ::std::os::raw::c_char,
        pname: *const ::std::os::raw::c_char,
        info: *mut DllInfo,
    ) -> R_altrep_class_t;
}
extern "C" {
    pub fn R_make_altinteger_class(
        cname: *const ::std::os::raw::c_char,
        pname: *const ::std::os::raw::c_char,
        info: *mut DllInfo,
    ) -> R_altrep_class_t;
}
extern "C" {
    pub fn R_make_altreal_class(
        cname: *const ::std::os::raw::c_char,
        pname: *const ::std::os::raw::c_char,
        info: *mut DllInfo,
    ) -> R_altrep_class_t;
}
extern "C" {
    pub fn R_make_altlogical_class(
        cname: *const ::std::os::raw::c_char,
        pname: *const ::std::os::raw::c_char,
        info: *mut DllInfo,
    ) -> R_altrep_class_t;
}
extern "C" {
    pub fn R_altrep_inherits(x: SEXP, arg1: R_altrep_class_t) -> Rboolean;
}
pub type R_altrep_Unserialize_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: SEXP) -> SEXP>;
pub type R_altrep_Serialized_state_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> SEXP>;
pub type R_altrep_Duplicate_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: Rboolean) -> SEXP>;
pub type R_altrep_Coerce_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: ::std::os::raw::c_int) -> SEXP>;
pub type R_altrep_Inspect_method_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: SEXP,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: SEXP,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: ::std::os::raw::c_int,
            ),
        >,
    ) -> Rboolean,
>;
pub type R_altrep_Length_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> R_xlen_t>;
pub type R_altvec_Dataptr_method_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: SEXP, arg2: Rboolean) -> *mut ::std::os::raw::c_void,
>;
pub type R_altvec_Dataptr_or_null_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> *const ::std::os::raw::c_void>;
pub type R_altinteger_Elt_method_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: SEXP, arg2: R_xlen_t) -> ::std::os::raw::c_int,
>;
pub type R_altinteger_Get_region_method_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: SEXP,
        arg2: R_xlen_t,
        arg3: R_xlen_t,
        arg4: *mut ::std::os::raw::c_int,
    ) -> R_xlen_t,
>;
pub type R_altinteger_Is_sorted_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> ::std::os::raw::c_int>;
pub type R_altinteger_No_NA_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> ::std::os::raw::c_int>;
pub type R_altinteger_Sum_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: Rboolean) -> SEXP>;
pub type R_altinteger_Min_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: Rboolean) -> SEXP>;
pub type R_altinteger_Max_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: Rboolean) -> SEXP>;
pub type R_altreal_Elt_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: R_xlen_t) -> f64>;
pub type R_altreal_Get_region_method_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: SEXP, arg2: R_xlen_t, arg3: R_xlen_t, arg4: *mut f64) -> R_xlen_t,
>;
pub type R_altreal_Is_sorted_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> ::std::os::raw::c_int>;
pub type R_altreal_No_NA_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> ::std::os::raw::c_int>;
pub type R_altreal_Sum_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: Rboolean) -> SEXP>;
pub type R_altreal_Min_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: Rboolean) -> SEXP>;
pub type R_altreal_Max_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: Rboolean) -> SEXP>;
pub type R_altlogical_Elt_method_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: SEXP, arg2: R_xlen_t) -> ::std::os::raw::c_int,
>;
pub type R_altlogical_Get_region_method_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: SEXP,
        arg2: R_xlen_t,
        arg3: R_xlen_t,
        arg4: *mut ::std::os::raw::c_int,
    ) -> R_xlen_t,
>;
pub type R_altlogical_Is_sorted_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> ::std::os::raw::c_int>;
pub type R_altlogical_No_NA_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> ::std::os::raw::c_int>;
pub type R_altlogical_Sum_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: Rboolean) -> SEXP>;
pub type R_altstring_Elt_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: R_xlen_t) -> SEXP>;
pub type R_altstring_Set_elt_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP, arg2: R_xlen_t, arg3: SEXP)>;
pub type R_altstring_Is_sorted_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> ::std::os::raw::c_int>;
pub type R_altstring_No_NA_method_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: SEXP) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn R_set_altrep_Unserialize_method(
        cls: R_altrep_class_t,
        fun: R_altrep_Unserialize_method_t,
    );
}
extern "C" {
    pub fn R_set_altrep_Serialized_state_method(
        cls: R_altrep_class_t,
        fun: R_altrep_Serialized_state_method_t,
    );
}
extern "C" {
    pub fn R_set_altrep_Duplicate_method(cls: R_altrep_class_t, fun: R_altrep_Duplicate_method_t);
}
extern "C" {
    pub fn R_set_altrep_Coerce_method(cls: R_altrep_class_t, fun: R_altrep_Coerce_method_t);
}
extern "C" {
    pub fn R_set_altrep_Inspect_method(cls: R_altrep_class_t, fun: R_altrep_Inspect_method_t);
}
extern "C" {
    pub fn R_set_altrep_Length_method(cls: R_altrep_class_t, fun: R_altrep_Length_method_t);
}
extern "C" {
    pub fn R_set_altvec_Dataptr_method(cls: R_altrep_class_t, fun: R_altvec_Dataptr_method_t);
}
extern "C" {
    pub fn R_set_altvec_Dataptr_or_null_method(
        cls: R_altrep_class_t,
        fun: R_altvec_Dataptr_or_null_method_t,
    );
}
extern "C" {
    pub fn R_set_altinteger_Elt_method(cls: R_altrep_class_t, fun: R_altinteger_Elt_method_t);
}
extern "C" {
    pub fn R_set_altinteger_Get_region_method(
        cls: R_altrep_class_t,
        fun: R_altinteger_Get_region_method_t,
    );
}
extern "C" {
    pub fn R_set_altinteger_Is_sorted_method(
        cls: R_altrep_class_t,
        fun: R_altinteger_Is_sorted_method_t,
    );
}
extern "C" {
    pub fn R_set_altinteger_No_NA_method(cls: R_altrep_class_t, fun: R_altinteger_No_NA_method_t);
}
extern "C" {
    pub fn R_set_altinteger_Sum_method(cls: R_altrep_class_t, fun: R_altinteger_Sum_method_t);
}
extern "C" {
    pub fn R_set_altinteger_Min_method(cls: R_altrep_class_t, fun: R_altinteger_Min_method_t);
}
extern "C" {
    pub fn R_set_altinteger_Max_method(cls: R_altrep_class_t, fun: R_altinteger_Max_method_t);
}
extern "C" {
    pub fn R_set_altreal_Elt_method(cls: R_altrep_class_t, fun: R_altreal_Elt_method_t);
}
extern "C" {
    pub fn R_set_altreal_Get_region_method(
        cls: R_altrep_class_t,
        fun: R_altreal_Get_region_method_t,
    );
}
extern "C" {
    pub fn R_set_altreal_Is_sorted_method(cls: R_altrep_class_t, fun: R_altreal_Is_sorted_method_t);
}
extern "C" {
    pub fn R_set_altreal_No_NA_method(cls: R_altrep_class_t, fun: R_altreal_No_NA_method_t);
}
extern "C" {
    pub fn R_set_altreal_Sum_method(cls: R_altrep_class_t, fun: R_altreal_Sum_method_t);
}
extern "C" {
    pub fn R_set_altreal_Min_method(cls: R_altrep_class_t, fun: R_altreal_Min_method_t);
}
extern "C" {
    pub fn R_set_altreal_Max_method(cls: R_altrep_class_t, fun: R_altreal_Max_method_t);
}
extern "C" {
    pub fn R_set_altlogical_Elt_method(cls: R_altrep_class_t, fun: R_altlogical_Elt_method_t);
}
extern "C" {
    pub fn R_set_altlogical_Get_region_method(
        cls: R_altrep_class_t,
        fun: R_altlogical_Get_region_method_t,
    );
}
extern "C" {
    pub fn R_set_altlogical_Is_sorted_method(
        cls: R_altrep_class_t,
        fun: R_altlogical_Is_sorted_method_t,
    );
}
extern "C" {
    pub fn R_set_altlogical_No_NA_method(cls: R_altrep_class_t, fun: R_altlogical_No_NA_method_t);
}
extern "C" {
    pub fn R_set_altlogical_Sum_method(cls: R_altrep_class_t, fun: R_altlogical_Sum_method_t);
}
extern "C" {
    pub fn R_set_altstring_Elt_method(cls: R_altrep_class_t, fun: R_altstring_Elt_method_t);
}
extern "C" {
    pub fn R_set_altstring_Set_elt_method(cls: R_altrep_class_t, fun: R_altstring_Set_elt_method_t);
}
extern "C" {
    pub fn R_set_altstring_Is_sorted_method(
        cls: R_altrep_class_t,
        fun: R_altstring_Is_sorted_method_t,
    );
}
extern "C" {
    pub fn R_set_altstring_No_NA_method(cls: R_altrep_class_t, fun: R_altstring_No_NA_method_t);
}
